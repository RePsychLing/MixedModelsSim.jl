var documenterSearchIndex = {"docs":
[{"location":"simulation/#Simulating-an-Experiment-from-Scratch","page":"Rapid Start","title":"Simulating an Experiment from Scratch","text":"","category":"section"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Here is a worked example of simulating a partially crossed design from scratch.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"First, some setup:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"using DataFrames\nusing MixedModels, MixedModelsSim\nusing Random","category":"page"},{"location":"simulation/#Assemble-the-Design","page":"Rapid Start","title":"Assemble the Design","text":"","category":"section"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"We're going to do a 2 x 2 x 2 design. For concreteness, let's think of this as a linguistic design:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"age old vs. young, between subjects\nfrequency high vs. low, between items\ncontext matched vs. unmatched, within both.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Further, let's assume we want 40 subjects and 80 items. We can specify this design as follows:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"n_subj = 40\nn_item = 80\nsubj_btwn = Dict(:age => [\"old\", \"young\"])\nitem_btwn = Dict(:frequency => [\"high\", \"low\"])\nboth_win = Dict(:context => [\"matched\", \"unmatched\"])","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"and then generate it:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"rng = MersenneTwister(42)  # specify our random number generator for reproducibility\ndesign = simdat_crossed(rng, n_subj, n_item;\n                        subj_btwn = subj_btwn,\n                        item_btwn = item_btwn,\n                        both_win = both_win)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Note that simdat_crossed returns a row table, which MixedModels.jl can process directly. For nicely displaying it, we can again use pretty_table:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"pretty_table(first(design, 5))","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"We can also convert it to a DataFrame and change the factors to use pooled arrays to save a bit of memory.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"df = pooled!(DataFrame(design))\nfirst(df, 5)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Note that simdat_crossed generated a column dv for our dependent variable that has been pre-populated with noise from a standard normal distribution (N(01)). Typically, we will want to scale that, but we can do that in the simulation step. Also, this dependent variable is pure noise: we haven't yet added in effects. Adding in effects also comes in the simulation step.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"But before we get to simulating, let's fit the model to the noise, just to see how things look. We're going to use effects coding for our contrasts.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"contrasts = Dict(:age => EffectsCoding(base=\"young\"),\n                 :frequency => EffectsCoding(base=\"high\"),\n                 :context => EffectsCoding(base=\"matched\"))\nform = @formula(dv ~ 1 + age * frequency * context +\n                    (1 + frequency + context | subj) +\n                    (1 + age + context | item))\nm0 = fit(MixedModel, form, design; contrasts=contrasts)","category":"page"},{"location":"simulation/#Assemble-the-Random-Effects","page":"Rapid Start","title":"Assemble the Random Effects","text":"","category":"section"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"The hard part in simulating right now is specifying the random effects. We're working on making this bit easier, but you need to specify the variance-covariance matrix of the random effects. You can see what this looks like:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"vc = VarCorr(m0)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"For each grouping variable (subjects and items), there are two major components: the standard deviations ahd the correlations.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"For this example, we'll just assume all the correlations and thus the covariances are 0 in order to make things simple. Then we only have to worry about the standard deviations.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Let's assume that the variability","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"between items\nin the intercept is 1.3 times the residual variability\nin age is 0.35 times the residual variability\nin context is 0.75 times the residual variability\nbetween subjects\nin the intercept is 1.5 times the residual variability\nin frequency is 0.5 times the residual variability\nin context is 0.75 times the residual variability","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Note these are always specified relative to the residual standard deviation. In other words, we think about how big the between-subject and between-item differences are relative to the between-observation differences.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"We can now create the associated covariance matrices.[cholesky]","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"[cholesky]: Technically, we're creating the lower Cholesky factor of these matrices, which is a bit like the matrix square root. In other words, we're creating the matrix form of standard deviations instead of the matrix form of the variances.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"re_item = create_re(1.3, 0.35, 0.75)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"re_subj = create_re(1.5, 0.5, 0.75)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"We can check that we got these right by installing these parameter values into the model.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"update!(m0; subj=re_subj, item=re_item)\nVarCorr(m0)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Looks good. The values don't exactly match the values in our parameter vector because the residual standard deviation isn't exactly 1.0.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"For the actual simulation, we'll need the compact form of these covariance matrices that MixedModels.jl uses internally. This compact form is the parameter vector θ and we can get it back out of the model where we just installed it:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"show(m0.θ)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Alternatively, we can also just generate θ directly from the random-effects matrices:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"θ = createθ(m0; subj=re_subj, item=re_item)\nshow(θ)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"We could also create it directly from the covariance matrices we created, but in this case we need to make sure they're in the same order as in the VarCorr output:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"θhand = vcat( flatlowertri(re_item), flatlowertri(re_subj) )\nshow(θhand)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"warning: Warning\nIn storing the parameter vector θ, MixedModels.jl uses an ordering that yields maximum sparseness, which enables better computational efficiency. The ordering is thus dependent on the entirety of the design – both the choice of the random effects and the relative number of subjects and items. For this reason, we strongly recommend using the helper methods that allow specifying the grouping variable by name.","category":"page"},{"location":"simulation/#Assemble-the-Fixed-Effects","page":"Rapid Start","title":"Assemble the Fixed Effects","text":"","category":"section"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"The last two components we need are the residual variance and the effect sizes for the fixed effects.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"σ = 5;\nβ = [1.0, -1.0, 2.0, -1.5, 0.3, -1.3, 1.4, 0];\nnothing # hide","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"The entries in the β correspond to the coefficients in the model given by","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"coefnames(m0)","category":"page"},{"location":"simulation/#Simulate","page":"Rapid Start","title":"Simulate","text":"","category":"section"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Now we're ready to actually simulate our data. We can use parametricbootstrap to do this: the parametric bootstrap actually works by simulating new data from an existing model and then looking at how the estimates fit to that new data look. In MixedModels.jl, you can specify different parameter values, such as the ones  we made up for our fake data.","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"# typically we would use a lot more simulations\n# but we want to be quick in this example\nsim = parametricbootstrap(MersenneTwister(12321), 20, m0; β=β, σ=σ, θ=θ)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"As mentioned above, the ordering within θ is dependent on the entire design, so if you embed the simulation code in a loop iterating over different numbers of subjects and items, it's probably better to write it as:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"sim = parametricbootstrap(MersenneTwister(12321), 20, m0;\n                          β=β, σ=σ, θ=createθ(m0; subj=re_subj, item=re_item))","category":"page"},{"location":"simulation/#See-your-power-and-profit!","page":"Rapid Start","title":"See your power and profit!","text":"","category":"section"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"Finally, we can turn this into a power table:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"ptbl = power_table(sim)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"For nicely displaying it, we can again use pretty_table:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"pretty_table(ptbl)","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"We can of course convert the row table into a DataFrame:","category":"page"},{"location":"simulation/","page":"Rapid Start","title":"Rapid Start","text":"DataFrame(ptbl)","category":"page"},{"location":"simulation_tutorial/#Power-Analysis-and-Simulation-Tutorial","page":"Beginner Friendly Tutorial","title":"Power Analysis and Simulation Tutorial","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"contributed by Lisa Schwetlick and Daniel Backhaus","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"This tutorial demonstrates how to conduct power analyses and data simulation using Julia and the MixedModelsSim package.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Power analysis is an important tool for planning an experimental design. Here we show how to:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Use existing data as a basis for power calculations by simulating new data.\nAdapt parameters in a given linear mixed model to analyze power without changing the existing data set.\nCreate a (simple) balanced fully crossed dataset from scratch and analyze power.\nRecreate a more complex dataset from scratch and analyze power for specific model parameter but various sample sizes.","category":"page"},{"location":"simulation_tutorial/#Setup","page":"Beginner Friendly Tutorial","title":"Setup","text":"","category":"section"},{"location":"simulation_tutorial/#Load-the-packages-we'll-be-using-in-Julia","page":"Beginner Friendly Tutorial","title":"Load the packages we'll be using in Julia","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"First, here are the packages needed in this example.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"using MixedModels        # run mixed models\nusing MixedModelsSim     # simulation utilities\nusing DataFrames, Tables # work with dataframes\nusing StableRNGs         # random number generator\nusing Statistics         # basic statistical functions\nusing DataFrameMacros    # dplyr-like operations\nusing CairoMakie         # plotting package\nCairoMakie.activate!(type=\"svg\") # use vector graphics\nusing MixedModelsMakie   # some extra plotting function for MixedModels\nusing ProgressMeter      # show progress in loops","category":"page"},{"location":"simulation_tutorial/#Define-number-of-iterations","page":"Beginner Friendly Tutorial","title":"Define number of iterations","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Here we define how many model simulations we want to do. A large number will give more reliable results, but will take longer to compute. It is useful to set it to a low number for testing, and increase it for your final analysis.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"# for real power analysis, set this much higher\nnsims = 100","category":"page"},{"location":"simulation_tutorial/#Use-existing-data-to-simulate-new-data","page":"Beginner Friendly Tutorial","title":"Use existing data to simulate new data","text":"","category":"section"},{"location":"simulation_tutorial/#Build-a-linear-mixed-model-from-existing-data","page":"Beginner Friendly Tutorial","title":"Build a linear mixed model from existing data","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"For the first example we are going to simulate data bootstrapped  from an existing data set, namely Experiment 2 from","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"dataset: Dataset\nKronmüller, E., & Barr, D. J. (2007). Perspective-free pragmatics: Broken precedents and the recovery-from-preemption hypothesis. Journal of Memory and Language, 56(3), 436-455.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"This was an experiment about how in a conversation the change of a speaker or the change of precedents (which are patterns of word usage to describe an object, e.g. one can refer to the same object \"white shoes\", \"runners\", \"sneakers\") affects the understanding.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"In experiment, objects were presented on a screen while participants listened to instructions to move the objects around. Participants' eye movements were tracked. The dependent variable is response time, defined as the latency between the onset of the test description and the moment at which the target was selected. The independent variables are speaker (old vs. new), precedents (maintain vs. break) and cognitive load (yes vs. no; from a secondary memory task).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We first load the data and define some characteristics like the contrasts and the underlying model. This dataset is one of the example datasets provided by MixedModels.jl.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Load existing data:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07 = MixedModels.dataset(:kb07);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set contrasts:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"contrasts = Dict(:spkr => HelmertCoding(),\n                 # set the reference level such that all the coefs\n                 # have the same sign, which makes the plotting nicer\n                 :prec => HelmertCoding(base=\"maintain\"),\n                 :load => HelmertCoding(),\n                 # pseudo-contrast for grouping variables\n                 :item => Grouping(),\n                 :subj => Grouping());","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The chosen linear mixed model (LMM) for this dataset is defined by the following model formula:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_f = @formula(rt_trunc ~ 1 + spkr + prec + load + (1|subj) + (1 + prec|item));","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Fit the model:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_m = fit(MixedModel, kb07_f, kb07; contrasts=contrasts)\nDisplayAs.Text(ans) # hide","category":"page"},{"location":"simulation_tutorial/#Simulate-from-existing-data-with-same-model-parameters","page":"Beginner Friendly Tutorial","title":"Simulate from existing data with same model parameters","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We will first look at the power of the dataset with the same parameters as in the original data set. This means that each dataset will have the exact number of observations as the original data. Here, we use the model kb07_m we fitted above to our dataset kb07.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"You can use the parametricbootstrap() function to run nsims iterations of data sampled using the parameters from kb07_m.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"info: Info\nThe parametric bootstrap is actually a simulation procedure. Each bootstrap iterationsimulates new data based on an existing model\nthen fits a model to that data to obtain new estimates.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set up a random seed to make the simulation reproducible. You can use your favourite number.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"To use multithreading, you need to set the number of worker threads you want to use. In VS Code, open the settings (gear icon in the lower left corner) and search for \"thread\". Set julia.NumThreads to the number of threads you want to use (at least 1 less than the total number of processor cores available, so that you can continue watching YouTube while the simulation runs).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set random seed for reproducibility:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"rng = StableRNG(42);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Run nsims iterations:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_sim = parametricbootstrap(rng, nsims, kb07_m);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The returned value kb07_sim contains the results of the bootstrapping procedure, which we can convert to a dataframe","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"df = DataFrame(kb07_sim.allpars);\nfirst(df, 12)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The dataframe df has 4500 rows: 9 parameters, each from 500 iterations.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"nrow(df)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We can now plot some bootstrapped parameters:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"fig = Figure()\n\nσres = @subset(df, :type == \"σ\" && :group == \"residual\")\nax = Axis(fig[1,1:2]; xlabel = \"residual standard deviation\", ylabel = \"Density\")\ndensity!(ax, σres.value)\n\nβInt = @subset(df, :type == \"β\" && :names == \"(Intercept)\")\nax = Axis(fig[1,3]; xlabel = \"fixed effect for intercept\")\ndensity!(ax, βInt.value)\n\nβSpeaker = @subset(df, :type == \"β\" && :names == \"spkr: old\")\nax = Axis(fig[2,1]; xlabel = \"fixed effect for spkr: old\", ylabel = \"Density\")\ndensity!(ax, βSpeaker.value)\n\nβPrecedents = @subset(df, :type == \"β\" && :names == \"prec: break\")\nax = Axis(fig[2,2]; xlabel = \"fixed effect for prec: break\")\ndensity!(ax, βPrecedents.value)\n\nβLoad = @subset(df, :type == \"β\" && :names == \"load: yes\")\nax = Axis(fig[2,3]; xlabel = \"fixed effect for load: yes\")\ndensity!(ax, βLoad.value)\n\nLabel(fig[0,:]; text = \"Parametric bootstrap replicates by parameter\", fontsize=25)\n\nfig","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"For the fixed effects, we can do this more succinctly via the ridgeplot functionality in MixedModelsMakie, even optionally omitting the intercept (which we often don't care about).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"ridgeplot(kb07_sim; show_intercept=false)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Next, we extract the p-values of the fixed-effects parameters into a dataframe","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_sim_df = DataFrame(kb07_sim.coefpvalues);\nfirst(kb07_sim_df, 8)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Now that we have a bootstrapped data, we can start our power calculation.","category":"page"},{"location":"simulation_tutorial/#Power-calculation","page":"Beginner Friendly Tutorial","title":"Power calculation","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The function power_table() from MixedModelsSim takes the output of parametricbootstrap() and calculates the proportion of simulations where the p-value is less than alpha for each coefficient. You can set the alpha argument to change the default value of 0.05 (justify your alpha).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"ptbl = power_table(kb07_sim, 0.05)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"An estimated power of 1 means that in every iteration the specific parameter we are looking at was below our alpha. An estimated power of 0.5 means that in half of our iterations the specific parameter we are looking at was below our alpha. An estimated power of 0 means that for none of our iterations the specific parameter we are looking at was below our alpha.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"You can also do it manually:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"prec_p = kb07_sim_df[kb07_sim_df.coefname .== Symbol(\"prec: break\"),:p]\nmean(prec_p .< 0.05)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"For a nicer display, you can use pretty_table:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"pretty_table(ptbl)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"warning: Warning\nThe simulation so far should not be interpreted as the power of the original K&B experiment. Observed power calculations are generally problematic. Instead, the example so far should serve to show how power can be computed using a simulation procedure.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"In the next section, we show how to use previously observed data – such as pilot data – as the basis for a simulation study with a different effect size.","category":"page"},{"location":"simulation_tutorial/#Adapt-parameters-in-a-given-linear-mixed-model-to-analyze-power-without-generating-additional-data","page":"Beginner Friendly Tutorial","title":"Adapt parameters in a given linear mixed model to analyze power without generating additional data","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Let's say we want to check our power to detect effects of spkr, prec, and load that are only half the size as in our pilot data. We can set a new vector of beta values (fixed effects) with the β argument to parametricbootstrap().","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Specify β:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"new_beta = kb07_m.β\nnew_beta[2:4] = kb07_m.β[2:4] / 2","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Run simulations:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_sim_half = parametricbootstrap(StableRNG(42), nsims, kb07_m; β = new_beta);","category":"page"},{"location":"simulation_tutorial/#Power-calculation-2","page":"Beginner Friendly Tutorial","title":"Power calculation","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"power_table(kb07_sim_half)","category":"page"},{"location":"simulation_tutorial/#Create-and-analyze-a-(simple)-balanced-fully-crossed-dataset-from-scratch","page":"Beginner Friendly Tutorial","title":"Create and analyze a (simple) balanced fully crossed dataset from scratch","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"In some situations, instead of using an existing dataset it may be useful to simulate the data from scratch. This could be the case when pilot data or data from a previous study are not available. Note that we still have to assume (or perhaps guess) a particular effect size, which can be derived from previous work (whether experimental or practical). In the worst case, we can start from the smallest effect size that we would find interesting or meaningful.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"In order to simulate data from scratch, we have to:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"specify the effect sizes manually\nmanually create an experimental design, according to which data can be simulated","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"If we simulate data from scratch, we can manipulate the arguments β, σ and θ (in addition to the number of subjects and items) Lets have a closer look at them, define their meaning and we will see where the corresponding values in the model output are.","category":"page"},{"location":"simulation_tutorial/#Fixed-Effects-(βs)","page":"Beginner Friendly Tutorial","title":"Fixed Effects (βs)","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"β are our effect sizes.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"If we look again on our LMM summary from the kb07-dataset kb07_m we see our four β under fixed-effects parameters in the Coef.-column.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_m\nDisplayAs.Text(ans) # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_m.β","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"(These can also be accessed with the appropriately named coef function.)","category":"page"},{"location":"simulation_tutorial/#Residual-Variance-(σ)","page":"Beginner Friendly Tutorial","title":"Residual Variance (σ)","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"σ is the residual-standard deviation listed under the variance components.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_m.σ","category":"page"},{"location":"simulation_tutorial/#Random-Effects-(θ)","page":"Beginner Friendly Tutorial","title":"Random Effects (θ)","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The meaning of θ is a bit less intuitive. In a less complex model (one that only has intercepts for the random effects) or if we suppress the correlations in the formula with zerocorr() then θ describes the relationship between the standard deviation of the random effects and the residual standard deviation.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"In our kb07_m example:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The residual standard deviation is 680.032.\nThe standard deviation of our first variance component item (Intercept) is 364.713.\nThus our first θ is the relationship: variance component divided by residual standard deviation: 364713   680032 =  053631","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_m.θ","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We also can calculate the θ for variance component subj (Intercept). The residual standard deviation is 680.032. The standard deviation of our variance component subj (Intercept) is 298.026. Thus, the related θ is the relationship: variance component divided by residual standard deviation 298.026 /  680.032 =  0.438252","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We can not calculate the θs for variance component item prec: break this way, because it includes the correlation of item prec: break and item (Intercept). But keep in mind that the relation of  item prec: break-variability (252.521) and the residual-variability (680.032) is 252521    680032 =  03713369.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The θ vector is the flattened version of the lower Cholesky factor variance-covariance matrix. The Cholesky factor is in some sense a \"matrix square root\" (so like storing standard deviations instead of variances) and is a lower triangular matrix. The on-diagonal elements are just the standard deviations (the σ's). If all off-diagonal elements are zero, we can use our calculation above. The off-diagonal elements are covariances and correspond to the correlations (the ρ's). If they are unequal to zero, as it is in our kb07-dataset, one way to get the two missing θ-values is to take the values directly from the model we have already fitted.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"See the two inner values:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_m.θ","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Another way is to make use of the create_re() function. Here you have to define the relation of all random effects variabilities to the variability of the residuals, as shown above, and the correlation-matrices.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Let's start by defining the correlation matrix for the item-part.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The diagonal is always 1.0 because everything is perfectly correlated with itself. The elements below the diagonal follow the same form as the Corr. entries in the output of VarCorr(). In our example the correlation of item prec: break and item (Intercept) is -0.7. The elements above the diagonal are just a mirror image.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"re_item_corr = [1.0 -0.7; -0.7 1.0]","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Now we put together all relations of standard deviations and the correlation-matrix for the item-group. This calculates the covariance factorization which is the theta matrix.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"re_item = create_re(0.536, 0.371; corrmat = re_item_corr)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"(Image: Work flow for constructing theta vector)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"note: Note\nDon't be too specific with your values in create_re(). Generally we don't these values very precisely because estimating them precisely requires large amounts of data. Additionally, if there are numerical problems (rounding errors), you will get the error-message: PosDefException: matrix is not Hermitian; Cholesky factorization failed.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Although we advise against using these values, you can extract the exact values like so (just as a pedagogical demonstration):","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"corr_exact = VarCorr(kb07_m).σρ.item.ρ[1]\nσ_residuals_exact = kb07_m.σ\nσ_1_exact = VarCorr(kb07_m).σρ.item.σ[1] / σ_residuals_exact\nσ_2_exact = VarCorr(kb07_m).σρ.item.σ[2] / σ_residuals_exact\n\nre_item_corr = [1.0 corr_exact; corr_exact 1.0]\nre_item = create_re(σ_1_exact, σ_2_exact; corrmat = re_item_corr)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Let's continue with the subj-part.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Since there the by-subject random effects have only one entry (the intercept), there are no correlations to specify and we can omit the corrmat argument.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Now we put together all relations of standard deviations and the correlation-matrix for the subj-group:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"This calculates the covariance factorization which is the theta matrix.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"re_subj = create_re(0.438)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"If you want the exact value you can use","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"σ_residuals_exact = kb07_m.σ\nσ_3_exact = VarCorr(kb07_m).σρ.subj.σ[1] / σ_residuals_exact\nre_subj = create_re(σ_3_exact)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"As mentioned above θ is the compact form of these covariance matrices:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"createθ(kb07_m; item=re_item, subj=re_subj)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The function createθ is putting the random effects into the correct order and then putting them into the compact form. Even for the same formula, the order may vary between datasets (and hence models fit to those datasets) because of a particular computational trick used in MixedModels.jl. Because of this trick, we need to specify the model along with the random effects so that the correct order can be determined.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We can install these parameter in the parametricbootstrap()-function or in the model like this:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"# need the fully qualified name here because Makie also defines update!\nMixedModelsSim.update!(kb07_m, item=re_item, subj=re_subj)\nDisplayAs.Text(ans) # hide","category":"page"},{"location":"simulation_tutorial/#A-simple-example-from-scratch","page":"Beginner Friendly Tutorial","title":"A simple example from scratch","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Having this knowledge about the parameters we can now simulate data from scratch","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The simdat_crossed() function from MixedModelsSim lets you set up a data frame with a specified experimental design. For now, it only makes fully balanced crossed designs, but you can generate an unbalanced design by simulating data for the largest cell and deleting extra rows.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"First, we will set an easy design where subj_n subjects per age group (Old or Young) respond to item_n items in each of two conditions (A or B).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Your factors need to be specified separately for between-subject, between-item, and within-subject/item factors using Dict with the name of each factor as the keys and vectors with the names of the levels as values.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We start with the between subject factors:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"subj_btwn = Dict(:age => [\"O\", \"Y\"])","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"There are no between-item factors in this design so you can omit it or set it to nothing. Note that if you have factors which are between subject and between item, you need to put them in both dicts.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"item_btwn = nothing","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Next, we put within-subject/item factors in a dict:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"both_win = Dict(:condition => [\"A\", \"B\"])","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define subject and item number:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"subj_n = 10\nitem_n = 30","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Simulate data:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"dat = simdat_crossed(subj_n,\n                     item_n,\n                     subj_btwn = subj_btwn,\n                     item_btwn = item_btwn,\n                     both_win = both_win);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Have a look:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"first(DataFrame(dat),8)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The values we see in the column dv is just random noise (drawn from the standard normal distribution)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set contrasts:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"contrasts = Dict(:age => HelmertCoding(),\n                 :condition => HelmertCoding(),\n                 :subj => Grouping(),\n                 :item => Grouping());","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define formula:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"f1 = @formula(dv ~ 1 + age * condition + (1|item) + (1|subj));","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Note that we did not include condition as random slopes for item and subject. This is mainly to keep the example simple and to keep the parameter θ easier to understand (see Section 3 above for the explanation of θ).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Fit the model:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"m1 = fit(MixedModel, f1, dat; contrasts=contrasts)\nDisplayAs.Text(ans) # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Because the dv is just random noise from N(0,1), there will be basically no subject or item random variance, residual variance will be near 1.0, and the estimates for all effects should be small. Don't worry, we'll specify fixed and random effects directly in parametricbootstrap().","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set random seed for reproducibility:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"rng = StableRNG(42);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Specify β, σ, and θ, we just made up this parameter:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"new_beta = [0., 0.25, 0.25, 0.]\nnew_sigma = 2.0\nnew_theta = [1.0, 1.0]","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Run nsims iterations:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"sim1 = parametricbootstrap(rng, nsims, m1;\n                           β = new_beta,\n                           σ = new_sigma,\n                           θ = new_theta);","category":"page"},{"location":"simulation_tutorial/#Power-calculation-3","page":"Beginner Friendly Tutorial","title":"Power calculation","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"ptbl= power_table(sim1)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"For nicely displaying it, you can use pretty_table:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"pretty_table(ptbl)","category":"page"},{"location":"simulation_tutorial/#Compute-power-curves-for-a-more-complex-dataset","page":"Beginner Friendly Tutorial","title":"Compute power curves for a more complex dataset","text":"","category":"section"},{"location":"simulation_tutorial/#Recreate-the-kb07-dataset-from-scratch","page":"Beginner Friendly Tutorial","title":"Recreate the kb07-dataset from scratch","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"For full control over all parameters in our kb07 data set we will recreate the design using the method shown above.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define subject and item number:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"subj_n = 56\nitem_n = 32","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define factors in a dict:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"subj_btwn = nothing\nitem_btwn = nothing\nboth_win = Dict(:spkr => [\"old\", \"new\"],\n                :prec => [\"maintain\", \"break\"],\n                :load => [\"yes\", \"no\"]);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Try: Play with simdat_crossed.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Simulate data:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"fake_kb07 = simdat_crossed(subj_n, item_n,\n                           subj_btwn = subj_btwn,\n                           item_btwn = item_btwn,\n                           both_win = both_win);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Make a dataframe:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"fake_kb07_df = DataFrame(fake_kb07);\nnothing # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Have a look:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"first(fake_kb07_df,8)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The function simdat_crossed generates a balanced fully crossed design. Unfortunately, our original design is not balanced fully crossed. Every subject saw an image only once, thus in one of eight possible conditions. To simulate that we only keep one of every eight lines.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We sort the dataframe to enable easier selection","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"sort!(fake_kb07_df, [:subj, :item, :load, :prec, :spkr])\nnothing # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"In order to select only the relevant rows of the data set we define an index which represents a random choice of one of every eight rows. First we generate a vector idx which represents which row to keep in each set of 8.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"len = div(length(fake_kb07), 8) # integer division\nidx = rand(rng, 1:8 , len)\nshow(idx)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Then we create an array A, of the same length that is populated multiples of the number 8. Added together A and idx give the indexes of one row from each set of 8s.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"A = repeat([8], inner=len-1)\npush!(A, 0)\nA = cumsum(A)\nidx = idx .+ A\nshow(idx)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Reduce the balanced fully crossed design to the original experimental design:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"fake_kb07_df= fake_kb07_df[idx, :]\nrename!(fake_kb07_df, :dv => :rt_trunc)\nnothing # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Now we can use the simulated data in the same way as above.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set contrasts:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"contrasts = Dict(:spkr => HelmertCoding(),\n                 :prec => HelmertCoding(),\n                 :load => HelmertCoding(),\n                 :item => Grouping(),\n                 :subj => Grouping());","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define formula, same as above:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_f = @formula(rt_trunc ~ 1 + spkr + prec + load + (1|subj) + (1+prec|item));","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Fit the model:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"fake_kb07_m = fit(MixedModel, kb07_f, fake_kb07_df; contrasts=contrasts)\nDisplayAs.Text(ans) # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set random seed for reproducibility:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"rng = StableRNG(42);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Then, again, we specify β, σ, and θ. Here we use the values that we found in the model of the existing dataset:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"#beta\nnew_beta = [2181.85, 67.879, -333.791, 78.5904] #manual\nnew_beta = kb07_m.β #grab from existing model\n\n#sigma\nnew_sigma = 680.032 #manual\nnew_sigma = kb07_m.σ #grab from existing model\n\n#theta\nre_item_corr = [1.0 -0.7; -0.7 1.0]\nre_item = create_re(0.536, 0.371; corrmat = re_item_corr)\nre_subj = create_re(0.438)\nnew_theta = createθ(kb07_m; item=re_item, subj=re_subj)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Run nsims iterations:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"fake_kb07_sim = parametricbootstrap(rng, nsims, fake_kb07_m,\n                        β = new_beta,\n                        σ = new_sigma,\n                        θ = new_theta);","category":"page"},{"location":"simulation_tutorial/#Power-calculation-4","page":"Beginner Friendly Tutorial","title":"Power calculation","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"power_table(fake_kb07_sim)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Compare to the powertable from the existing data:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"power_table(kb07_sim)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"We have successfully recreated the power simulation of an existing dataset from scratch. This has the advantage, that we now can iterate over different numbers of subjects and items.","category":"page"},{"location":"simulation_tutorial/#Loop-over-subject-and-item-sizes","page":"Beginner Friendly Tutorial","title":"Loop over subject and item sizes","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"When designing a study, you may be interested in trying various numbers of subjects and items to see how that affects the power of your study. To do this you can use a loop to run simulations over a range of values for any parameter.","category":"page"},{"location":"simulation_tutorial/#We-first-define-every-fixed-things-outside-the-loop-(same-as-above):","page":"Beginner Friendly Tutorial","title":"We first define every fixed things outside the loop (same as above):","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define factors in a dict:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"subj_btwn = nothing\nitem_btwn = nothing\nboth_win = Dict(:spkr => [\"old\", \"new\"],\n                :prec => [\"maintain\", \"break\"],\n                :load => [\"yes\", \"no\"]);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set contrasts:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"contrasts = Dict(:spkr => HelmertCoding(),\n                 :prec => HelmertCoding(base=\"maintain\"),\n                 :load => HelmertCoding());","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Set random seed for reproducibility:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"rng = StableRNG(42);","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define formula:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"kb07_f = @formula(rt_trunc ~ 1 + spkr + prec + load + (1 | subj) + (1 + prec | item));","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"a Specify β, σ, and θ:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"#beta\nnew_beta = [2181.85, 67.879, -333.791, 78.5904]\nnew_beta = kb07_m.β\n\n#sigma\nnew_sigma = 680.032\nnew_sigma = kb07_m.σ\n\n#theta\nre_item_corr = [1.0 -0.7; -0.7 1.0]\nre_item = create_re(0.536, 0.371; corrmat = re_item_corr)\nre_subj = create_re(0.438)\n# because the ordering in theta is dependent on the design,\n# we will create it within the loop as we change the design parameters\n# (e.g. n subjects and n items)","category":"page"},{"location":"simulation_tutorial/#Then-we-define-the-variables-that-out-loop-will-iterate-over","page":"Beginner Friendly Tutorial","title":"Then we define the variables that out loop will iterate over","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Define subject and item numbers as arrays:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"sub_ns = [20, 30, 40];\nitem_ns = [16, 24, 32];","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Make an empty dataframe:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"d = DataFrame();\nnothing # hide","category":"page"},{"location":"simulation_tutorial/#Run-the-loop:","page":"Beginner Friendly Tutorial","title":"Run the loop:","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"@showprogress for subj_n in sub_ns, item_n in item_ns\n    # Make balanced fully crossed data:\n    fake = simdat_crossed(subj_n, item_n;\n                          subj_btwn = subj_btwn,\n                          item_btwn = item_btwn,\n                          both_win = both_win);\n    fake_df = DataFrame(fake)\n\n    # Reduce the balanced fully crossed design to the original experimental design:\n    fake_df = sort(fake_df, [:subj, :item, :load, :prec, :spkr])\n    local len = convert(Int64,(length(fake)/8))\n    local idx = rand(rng, collect(1:8) , len)\n    local A = repeat([8], inner=len-1)\n    push!(A, 0)\n    A = cumsum(A)\n    idx = idx + A\n    fake_df = fake_df[idx, :]\n    rename!(fake_df, :dv => :rt_trunc)\n\n    # create the model:\n    fake_m = LinearMixedModel(kb07_f, fake_df, contrasts=contrasts);\n    local new_theta = createθ(fake_m; item=re_item, subj=re_subj)\n    # Run nsims iterations:\n    fake_sim = parametricbootstrap(rng, nsims, fake_m,\n                                   β = new_beta,\n                                   σ = new_sigma,\n                                   θ = new_theta,\n                                   progress=false);\n\n    # Power calculation\n    local ptbl = power_table(fake_sim)\n    ptdf = DataFrame(ptbl)\n    ptdf[!, :item_n] .= item_n\n    ptdf[!, :subj_n] .= subj_n\n    append!(d, ptdf)\nend\nnothing # hide","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Our dataframe d now contains the power information for each combination of subjects and items.","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"first(d, 10)","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Lastly we plot our results:","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"function subplot_power(f::Figure, dat, coefname)\n    coefpow = @subset(dat, :coefname == coefname)\n    ax = Axis(f;\n              xlabel=\"n subjects\",\n              ylabel=\"n items\",\n              #aspect=AxisAspect(1),\n              title=\"$(coefname)\")\n    heatmap!(ax, coefpow.subj_n, coefpow.item_n, coefpow.power; colorrange=[0,1])\n    return ax\nend\n\nfig = Figure(; resolution=(1300,300))\nfor (idx, cn) in enumerate(sort(unique(d.coefname)))\n    fig[1, idx] = subplot_power(fig, d, cn)\nend\nColorbar(fig[1, end+1]; label=\"power\", vertical=true, colorrange=[0,1], colormap=:viridis)\nfig","category":"page"},{"location":"simulation_tutorial/#Acknowledgements","page":"Beginner Friendly Tutorial","title":"Acknowledgements","text":"","category":"section"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"The text here is based on a tutorial presented at a ZiF workshop by Lisa DeBruine (Feb. 2020) and presented again by Phillip Alday during the SMLP Summer School (Sep. 2020).","category":"page"},{"location":"simulation_tutorial/","page":"Beginner Friendly Tutorial","title":"Beginner Friendly Tutorial","text":"Updated and extended by Lisa Schwetlick & Daniel Backhaus, with the kind help of Phillip Alday, after changes to the package.","category":"page"},{"location":"#MixedModelsSim.jl","page":"MixedModelsSim.jl","title":"MixedModelsSim.jl","text":"","category":"section"},{"location":"","page":"MixedModelsSim.jl","title":"MixedModelsSim.jl","text":"","category":"page"},{"location":"#MixedModelsSim._update!-Tuple{MixedModels.LinearMixedModel, Any}","page":"MixedModelsSim.jl","title":"MixedModelsSim._update!","text":"_update!(m::MixedModel, θ)\n\nUpdate the mixed model to use θ as its new parameter vector.\n\nnote: Note\nThis is a convenience function for installing a particular parameter vector and the resulting model fit. It does not actually perform any type of optimization.\n\nnote: Note\nFor GLMMs, this only sets θ and not β, even for fast=false fits.\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.create_re-Tuple","page":"MixedModelsSim.jl","title":"MixedModelsSim.create_re","text":"create_re(sigmas...; corrmat=Matrix{Float64}(I, length(sigmas), length(sigmas))\n\nCreate the covariance factor for a random effect from the standard deviations and correlation matrix.\n\nThe sigmas should be specified in the same order as the random slopes in the output of VarCorr(m).\n\nnote: Note\nThe sigmas are specified relative to the residual standard deviation.  Absolute values must be scaled by dividing by the assumed residual  standard deviation.\n\nThe correlation matrix defaults to the identity matrix, i.e. no correlation between random effects.\n\nnote: Note\nThe return value is the lower Cholesky factor of the covariance matrix, which is what update! requires.\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.createθ-Tuple{MixedModels.MixedModel}","page":"MixedModelsSim.jl","title":"MixedModelsSim.createθ","text":"createθ(m::MixedModel; named_re)\ncreate_theta(m::MixedModel; named_re)\n\nCreate the parameter vector θ corresponding to the random effects.\n\nThe named_re can be created using create_re. The named_re are specified by the name of the blocking variable, e.g. subj=create_re(...).\n\nThe model must be specified because the parameters are sorted internally for computational efficiency.\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.cyclicshift-Tuple{AbstractVector, Any}","page":"MixedModelsSim.jl","title":"MixedModelsSim.cyclicshift","text":"cyclicshift(v::AbstractVector, nrow)\n\nReturn an eltype(v) matrix of size nrow by length(v) with each column consisting of v followed by a cyclic shift of v followed by ...\n\ncyclicshift('a':'d', 8)\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.factorproduct-Tuple","page":"MixedModelsSim.jl","title":"MixedModelsSim.factorproduct","text":"factorproduct(facs...)\n\nReturn a Vector{NamedTuple} obtained by crossing facs....\n\nThe arguments should be coerceable to a Tables.RowTable with rowtable.\n\nThe value is a Tables.RowTable and hence can be converted to a DataFrame.\n\nExample\n\njulia> DataFrame(factorproduct((item=nlevels(3,'I'),), (subj=nlevels(5), age=[\"Y\",\"Y\",\"Y\",\"O\",\"O\"])))\n15×3 DataFrame\n│ Row │ item   │ subj   │ age    │\n│     │ String │ String │ String │\n├─────┼────────┼────────┼────────┤\n│ 1   │ I1     │ S1     │ Y      │\n│ 2   │ I2     │ S1     │ Y      │\n│ 3   │ I3     │ S1     │ Y      │\n│ 4   │ I1     │ S2     │ Y      │\n│ 5   │ I2     │ S2     │ Y      │\n│ 6   │ I3     │ S2     │ Y      │\n│ 7   │ I1     │ S3     │ Y      │\n│ 8   │ I2     │ S3     │ Y      │\n│ 9   │ I3     │ S3     │ Y      │\n│ 10  │ I1     │ S4     │ O      │\n│ 11  │ I2     │ S4     │ O      │\n│ 12  │ I3     │ S4     │ O      │\n│ 13  │ I1     │ S5     │ O      │\n│ 14  │ I2     │ S5     │ O      │\n│ 15  │ I3     │ S5     │ O      │\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.flatlowertri-Tuple{LinearAlgebra.LowerTriangular}","page":"MixedModelsSim.jl","title":"MixedModelsSim.flatlowertri","text":"flatlowertri(::LowerTriangular)\n\nReturns the lower triangular flattened into 1D array in column-major order.\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.nlevels","page":"MixedModelsSim.jl","title":"MixedModelsSim.nlevels","text":"nlevels(nlev, tag='S')\n\nReturn a Vector{String} of tag followed by 1:nlev left-padded with zeros\n\nExamples\n\njulia> show(nlevels(10))\n[\"S01\", \"S02\", \"S03\", \"S04\", \"S05\", \"S06\", \"S07\", \"S08\", \"S09\", \"S10\"]\n\n\n\n\n\n","category":"function"},{"location":"#MixedModelsSim.nlevstbl-Tuple{Symbol, Integer, Vararg{Pair{Symbol, Vector{String}}}}","page":"MixedModelsSim.jl","title":"MixedModelsSim.nlevstbl","text":"nlevstbl(nm::Symbol, n, vars::Pair{Symbol, Vector{String}}...)\n\nReturn a Tables.columntable with a nm column as a PooledArray with n levels.\n\nIf any vars pairs are given they are expanded to columns representing characteristics of the nm column.  In experimental design terminology, if say nm is :item then these represent between-item experimental factors.\n\nThe nm column is generated as nlevels(n, uppercase(first(string(nm))))\n\nExamples\n\njulia> nlevstbl(:item, 10)\n(item = [\"I01\", \"I02\", \"I03\", \"I04\", \"I05\", \"I06\", \"I07\", \"I08\", \"I09\", \"I10\"],)\n\njulia> nlevstbl(:item, 9, :level => [\"low\", \"medium\", \"high\"])\n(item = [\"I1\", \"I2\", \"I3\", \"I4\", \"I5\", \"I6\", \"I7\", \"I8\", \"I9\"], level = [\"low\", \"medium\", \"high\", \"low\", \"medium\", \"high\", \"low\", \"medium\", \"high\"])\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.pooled!","page":"MixedModelsSim.jl","title":"MixedModelsSim.pooled!","text":"pooled!(df, cols::Type=Union{AbstractString,Missing})\n\nLike DataFrames.categorical! but converting columns to PooledArrays\n\nwarning: Warning\nThis method is not type-specific in the first argument, in order to eliminate a dependency on DataFrames.jl. It nonetheless expects a DataFrame as its first argument\n\n\n\n\n\n","category":"function"},{"location":"#MixedModelsSim.power_table","page":"MixedModelsSim.jl","title":"MixedModelsSim.power_table","text":"power_table(sim, alpha = 0.05)\n\nReturns a row table with fields coefname and power  based on the proportion of simulated p-values less than alpha, for sim, the output of parametricbootstrap.\n\n\n\n\n\n","category":"function"},{"location":"#MixedModelsSim.simdat_crossed-Tuple","page":"MixedModelsSim.jl","title":"MixedModelsSim.simdat_crossed","text":"simdat_crossed([RNG], subj_n, item_n;\n               subj_btwn=nothing, item_btwn=nothing, both_win=nothing,\n               subj_prefix=\"S\", item_prefix=\"I\")\n\nReturn a row table with a design specified by the:\n\nnumber of subjects (subj_n),\nnumber of items (item_n)\nbetween-subject factors (subj_btwn)\nbetween-item factors (item_btwn)\nwithin-subject/item factors (both_win)\n\nIf a factor is both between-subject and between-item, put it in both subj_btwn and item_btwn with the same keys and the same levels.\n\nFactors should be specified as dictionaries in the following format:\n\nDict(\n    :factor1_name => [\"F1_level1\", \"F1_level2\"],\n    :factor2_name => [\"F2_level1\", \"F2_level2\", \"F2_level3\"]\n)\n\nIn addition to design, the rowtable contains a field dv pre-populated with N(0,1) noise as a basis for further simulating a design.\n\nnote: Note\nThe number of subjects/items must divide the number of combinations of between subject/item factor levels. In other words, this function assumes a balanced design and will throw an error if that is not possible.\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.update!-Tuple{MixedModels.MixedModel, Vararg{Any}}","page":"MixedModelsSim.jl","title":"MixedModelsSim.update!","text":"update!(m::MixedModel, re...)\n\nUpdate the mixed model to use the random-effects covariance matrices.\n\nThe re can be created using create_re.\n\nThey should be specified in the order specified in VarCorr(m).\n\nwarning: Warning\nWe recommend against calling this method directly. Instead, use the method with keyword arguments to specify the  different re by name.\n\nnote: Note\nThis is a convenience function for installing a particular parameter vector and the resulting model fit. It does not actually perform any type of optimization.\n\nDetails\n\nThe re used as the λ fields of the model's ReTerms and should be specified as the lower Cholesky factor of covariance matrices.\n\n\n\n\n\n","category":"method"},{"location":"#MixedModelsSim.update!-Tuple{MixedModels.MixedModel}","page":"MixedModelsSim.jl","title":"MixedModelsSim.update!","text":"update!(m::MixedModel; namedre...)\nupdate!(m::MixedModel; θ)\n\nUpdate the mixed model to use the random-effects covariance matrices.\n\nThe namedre can be created using create_re. The namedre are specified by the name of the blocking variable, e.g. subj=create_re(...).\n\nwarning: Warning\nThe model's response must be initialized to a non-constant value before calling this function, otherwise the model update will fail with a  PosDefException.\n\nwarning: Warning\nSetting θ directly as a keyword-argument is deprecated.\n\nnote: Note\nThis is a convenience function for installing a particular parameter vector and the resulting model fit. It does not actually perform any type of optimization.\n\nDetails\n\nThe re is used as the λ fields of the model's ReTerms and should be specified as the lower Cholesky factor of covariance matrices.\n\n\n\n\n\n","category":"method"}]
}
